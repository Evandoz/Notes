<!DOCTYPE html>
<html>
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  
  <title>内部排序总结 | EXP Notes</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
    <meta name="author" content="Levan">
  
  
    <meta name="description" content="日常记录与分享">
  
  
    <meta name="keywords" content="内部排序">
  
  
    <meta name="google-site-verification" content="W2AVg5n_ALo21rl9n3ZwS8AuEanZfJkirzrRGLLYvn4">
  
  
    <meta name="baidu-site-verification" content="BM2Q3xLpPJ">
  
  
    <meta name="360-site-verification" content="573211edf2de02c99d7b255b2c56513c">
  
  
    <link rel="short icon" type="image/x-icon" href="/Notes/css/images/favicon.ico">
  
  <link rel="canonical" href="https://evandoz.github.io/Notes/archives/77584019872a.html">
  
<link rel="stylesheet" href="/Notes/css/style.css">

<meta name="generator" content="Hexo 5.3.0"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head>

<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="overflow" class="overflow">
    <div id="hiddenbar" class="hiddenbar">
      <div id="wrapper" class="wrapper">
        <header id="header" class="header is-post">
  <div class="outer">
    <div class="logo">
      <a class="title" href="/Notes/">EXP Notes</a>
    </div>
    <div class="nav">
      <ul id="nav-icon" class="nav-icon">
        <li></li><li></li><li></li>
      </ul>
      <ul class="nav-menu">
        
          <li class="nav-item">
            <a href="/Notes/archives">归档</a>
          </li>
        
          <li class="nav-item">
            <a href="/Notes/categories">分类</a>
          </li>
        
          <li class="nav-item">
            <a href="/Notes/tags">标签</a>
          </li>
        
          <li class="nav-item">
            <a href="/Notes/about">关于</a>
          </li>
        
      </ul>
    </div>

  </div>
</header>

        <div id="content" class="content">
    <section class="article-header inner">
      <img src="/Notes/css/images/banner2.jpg" alt="banner">
      

      
  
  	<h1 class="post-title">内部排序总结</h1>
  


      <div class="post-meta">
        <span class="post-date">
  <time datetime="2016-09-25T16:00:00.000Z">2016-09-26</time>
</span>

        
  <span class="post-category">
    <a class="category-link" href="/Notes/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a> · <a class="category-link" href="/Notes/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8E%92%E5%BA%8F/">排序</a>
  </span>


      </div>
    </section>
    <section class="article-body inner">
      <div id="side" class="aside post left">

      </div>
      <div class="main">
        <article id="数据结构/排序/20160926-内部排序总结" class="article">
          <div id="post-content" class="post-content">
            <h2 id="各项指标对比"><a class="headerlink" href="#各项指标对比"></a>各项指标对比</h2>
<h3 id="时空复杂度及稳定性"><a class="headerlink" href="#时空复杂度及稳定性"></a>时空复杂度及稳定性</h3>
<table>
<thead>
<tr>
<th>排序算法</th>
<th style="text-align:center">最好情况</th>
<th style="text-align:center">最坏情况</th>
<th style="text-align:center">平均情况</th>
<th style="text-align:center">空间复杂度</th>
<th style="text-align:center">稳定性</th>
</tr>
</thead>
<tbody>
<tr>
<td>直接插入排序</td>
<td style="text-align:center">O(n)</td>
<td style="text-align:center">O(n<sup>2</sup>)</td>
<td style="text-align:center">O(n<sup>2</sup>)</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">稳定</td>
</tr>
<tr>
<td>希尔排序</td>
<td style="text-align:center">O(n<sup>1.3</sup>)</td>
<td style="text-align:center">O(n<sup>2</sup>)</td>
<td style="text-align:center"></td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">不稳定</td>
</tr>
<tr>
<td>冒泡排序</td>
<td style="text-align:center">O(n)</td>
<td style="text-align:center">O(n<sup>2</sup>)</td>
<td style="text-align:center">O(n<sup>2</sup>)</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">稳定</td>
</tr>
<tr>
<td>快速排序</td>
<td style="text-align:center">O(nlog<sub>2</sub>n)</td>
<td style="text-align:center">O(n<sup>2</sup>)</td>
<td style="text-align:center">O(nlog<sub>2</sub>n)</td>
<td style="text-align:center">O(log<sub>2</sub>n)</td>
<td style="text-align:center">不稳定</td>
</tr>
<tr>
<td>简单选择排序</td>
<td style="text-align:center">O(n<sup>2</sup>)</td>
<td style="text-align:center">O(n<sup>2</sup>)</td>
<td style="text-align:center">O(n<sup>2</sup>)</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">不稳定</td>
</tr>
<tr>
<td>堆排序</td>
<td style="text-align:center">O(nlog<sub>2</sub>n)</td>
<td style="text-align:center">O(nlog<sub>2</sub>n)</td>
<td style="text-align:center">O(nlog<sub>2</sub>n)</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">不稳定</td>
</tr>
<tr>
<td>归并排序</td>
<td style="text-align:center">O(nlog<sub>2</sub>n)</td>
<td style="text-align:center">O(nlog<sub>2</sub>n)</td>
<td style="text-align:center">O(nlog<sub>2</sub>n)</td>
<td style="text-align:center">O(n)</td>
<td style="text-align:center">稳定</td>
</tr>
<tr>
<td>基数排序</td>
<td style="text-align:center">O(d(n+r))</td>
<td style="text-align:center">O(d(n+r))</td>
<td style="text-align:center">O(d(n+r))</td>
<td style="text-align:center">O®</td>
<td style="text-align:center">稳定</td>
</tr>
</tbody>
</table>
<p>对n较大的排序记录。一般的选择都是时间复杂度为 O(nlog<sub>2</sub>n) 的排序方法。</p>
<ol>
<li>从时间复杂度角度：</li>
</ol>
<ul>
<li>平方阶排序 O(n<sup>2</sup>)：直接插入排序、冒泡排序和简单选择排序，这三个一般称为简单排序；</li>
<li>线性对数阶排序 O(nlog<sub>2</sub>n)：快速排序、堆排序和归并排序；</li>
<li>O(n<sup>1+§</sup>))排序，§是介于0和1之间的常数：希尔排序；</li>
<li>线性阶排序 O(n)：基数排序（计数排序、桶/箱排序）。</li>
</ul>
<p>原序列有序或基本有序时，直接插入排序和冒泡排序将大大减少比较次数和移动记录的次数，时间复杂度可降至 O(n)；</p>
<p>原序列基本有序时，快速排序将蜕化为冒泡排序，时间复杂度提高为 O(n<sup>2</sup>)；</p>
<p>由于一些数学上的问题为未解决，所以希尔排序的时间复杂度尚无精确渐近时间；</p>
<p>原序列初始状态（是否有序），对简单选择排序、堆排序、归并排序和基数排序的时间复杂度影响不大。</p>
<ol start="2">
<li>空间复杂度</li>
</ol>
<p>简单排序、希尔排序和堆排序需要常数个辅助空间用于元素的移动、交换等操作；</p>
<p>快速排序需要一个小递归栈实现递归，平均大小为 O(log<sub>2</sub>n)，最坏会变成 O(n)；</p>
<p>归并排序需要更多空间用于合并操作；</p>
<ol start="3">
<li>稳定性</li>
</ol>
<p>稳定性的好处：排序算法如果是稳定的，那么从一个键上排序，然后再从另一个键上排序，第一个键排序的结果可以为第二个键排序所用。基数排序就是这样，先按低位排序，逐次按高位排序，低位相同的元素其顺序再高位也相同时是不会改变的。另外，如果排序算法稳定，可以避免多余的比较；</p>
<p>稳定排序：直接插入排序、冒泡排序、归并排序、基数排序</p>
<p>不稳定排序：希尔排序、快速排序、选择排序、堆排序</p>
<h3 id="过程特征"><a class="headerlink" href="#过程特征"></a>过程特征</h3>
<table>
<thead>
<tr>
<th>排序算法</th>
<th>一趟排序能否确定一个元素位置</th>
<th>能否产生有序子序列</th>
<th>局部/全局</th>
</tr>
</thead>
<tbody>
<tr>
<td>直接插入排序</td>
<td>不能</td>
<td>能</td>
<td>局部有序</td>
</tr>
<tr>
<td>希尔排序</td>
<td>不能</td>
<td>不能</td>
<td>X</td>
</tr>
<tr>
<td>冒泡排序</td>
<td>能（最值）</td>
<td>能</td>
<td>全局有序</td>
</tr>
<tr>
<td>快速排序</td>
<td>能 （基准值）</td>
<td>不能</td>
<td>X</td>
</tr>
<tr>
<td>简单选择排序</td>
<td>能（最值）</td>
<td>能</td>
<td>全局有序</td>
</tr>
<tr>
<td>堆排序</td>
<td>能（最值）</td>
<td>能</td>
<td>全局有序</td>
</tr>
<tr>
<td>归并排序</td>
<td>不能</td>
<td>能</td>
<td>局部有序</td>
</tr>
<tr>
<td>基数排序</td>
<td>不能</td>
<td>不能</td>
<td>X</td>
</tr>
</tbody>
</table>
<h2 id="应用场景选择"><a class="headerlink" href="#应用场景选择"></a>应用场景选择</h2>
<h3 id="选用算法的考虑因素"><a class="headerlink" href="#选用算法的考虑因素"></a>选用算法的考虑因素</h3>
<p>每种排序算法都各有优缺点，在实用时需根据不同情况适当选用，甚至可以将多种方法结合起来使用。</p>
<p>影响排序的因素有很多，平均时间复杂度低的算法并不一定就是最优的。相反，有时平均时间复杂度高的算法可能更适合某些特殊情况。同时，选择算法时还得考虑它的可读性，以利于软件的维护。</p>
<p>一般而言，需要考虑的因素有以下几点：</p>
<p>1．待排序的元素数目 n 的大小；<br>
2．元素本身数据量的大小，也就是元素中除关键字外的其他信息量的大小；<br>
3．关键字的结构及其分布情况；<br>
4．对排序稳定性的要求；<br>
5. 语言工具条件，存储结构及辅助空间大小等。</p>
<h3 id="选用算法的基本场景"><a class="headerlink" href="#选用算法的基本场景"></a>选用算法的基本场景</h3>
<ol>
<li>
<p>当 n 较小（n≤50），可采用直接插入排序或简单选择排序；<br>
直接插入排序移动操作次数较多，如果元素本身信息量较大时，不建议使用，转而用简单选择排序。</p>
</li>
<li>
<p>原序列基本有序时，可选用直接插入排序或冒泡排序；</p>
</li>
<li>
<p>当n较大，则应采用时间复杂度为 O(nlog<sub>2</sub>n) 的排序方法：快速排序、堆排序、归并排序。<br>
快速排序：是目前基于比较的内部排序中被认为是最好的方法，当待排序的关键字是随机分布时，快速排序的平均时间最短；<br>
堆排序：辅助空间少，不会出现快速排序的最坏情况；<br>
归并排序：相较于前两者，归并排序时稳定的，不过要求的辅助空间较多；归并排序不建议单独使用，通常与插入排序组合，先获得一定长度的序列，然后再合并，在效率上将有所提高。</p>
</li>
<li>
<p>基数排序是一种稳定的排序算法，但有一定的局限性：<br>
　　（1）关键字可分解<br>
　　（2）记录的关键字位数较少，如果密集更好<br>
　　（3）如果是数字时，最好是无符号的，否则将增加相应的映射复杂度，可先将其正负分开排序</p>
</li>
<li>
<p>元素本身信息量很大时，为避免过多的移动操作，可改用（静态）链表存储；但是由于一些排序依赖于存储结构，如希尔排序、快速排序、堆排序等依赖于顺序存储，为了解决这个矛盾，可以进行地址排序，即另设一个地址向量指示相应元素，排序过程中移动地址向量而不移动元素。</p>
</li>
</ol>
<h2 id="基于比较排序的分析"><a class="headerlink" href="#基于比较排序的分析"></a>基于比较排序的分析</h2>
<p>对 n 个记录进行排序至少需进行多少次关键字间的比较？</p>
<p>基于比较的排序，每次比较两个关键字大小后，仅出现两种可能的转移，因此可以用一棵二叉判定树来描述基于“比较”的排序过程，判定树上的每一次比较都是必须的，容易得到，每个初始序列达到最终有序所进行的<strong>比较次数</strong>，恰好是从树根到该最终序列相应叶子节点的<strong>路径长度</strong>，即 高度为 h 的判定树，至少要进行 h-1 次比较。</p>
<p>现假设有 n 个元素，可能出现的序列状态有 n! 个，即判定树必须有 n! 个叶子节点，少一个就说明上有两种状态未分辨出来。叶子数为 n! 的完全二叉树的高度（深度）为  ⌈log(n!)⌉+1。</p>
<p>因此基于比较的排序算法，在最坏情况下所需要进行比较的次数至少为 ⌈log(n!)⌉，不过这只是理论下届，一般的排序算法在 n&gt;4 时所需要的比较次数均大于这个值。</p>
<p>1956年，Demuth 首先找到了对 5 个数进行排序只需要 7 次比较的方法后，Lester Ford 和 Selmer Johnson 将其推广，提出了归并插入排序，在 n&lt;11 时所用的比较次数和 ⌈log(n!)⌉ 相同。</p>
<p>根据斯特林公式，⌈log(n!)⌉=O(nlogn)，因此基于比较的排序算法在最坏情况下能达到的最好时间复杂度为 O(nlogn)。</p>

          </div>
          <div class="post-footer">
            <div class="post-copyright">&copy; 除特殊声明外，文章著作权归作者所有，转载请注明作者及出处</div>
          </div>
        </article>
        <!-- Pagination -->
        
          <div class="nagination card">
            
              <a href="/Notes/archives/63cee1402d2d" class="nagination-link">上篇: Sublime Text 3 配置文件的中文释义</a>
            
            
              <a href="/Notes/archives/b5da7fac9484" class="nagination-link">下篇: 基数排序</a>
            
          </div>
        
        <!-- Comment -->
        <!-- 
          <div id="article-comment" class="article-comment card"></div>

         -->
      </div>
      <div id="toc" class="toc">
        
          <ol class="toc-content"><li class="toc-content-item toc-content-level-2"><a class="toc-content-link" href="#%E5%90%84%E9%A1%B9%E6%8C%87%E6%A0%87%E5%AF%B9%E6%AF%94"><span class="toc-content-text">各项指标对比</span></a><ol class="toc-content-child"><li class="toc-content-item toc-content-level-3"><a class="toc-content-link" href="#%E6%97%B6%E7%A9%BA%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%8F%8A%E7%A8%B3%E5%AE%9A%E6%80%A7"><span class="toc-content-text">时空复杂度及稳定性</span></a></li><li class="toc-content-item toc-content-level-3"><a class="toc-content-link" href="#%E8%BF%87%E7%A8%8B%E7%89%B9%E5%BE%81"><span class="toc-content-text">过程特征</span></a></li></ol></li><li class="toc-content-item toc-content-level-2"><a class="toc-content-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E9%80%89%E6%8B%A9"><span class="toc-content-text">应用场景选择</span></a><ol class="toc-content-child"><li class="toc-content-item toc-content-level-3"><a class="toc-content-link" href="#%E9%80%89%E7%94%A8%E7%AE%97%E6%B3%95%E7%9A%84%E8%80%83%E8%99%91%E5%9B%A0%E7%B4%A0"><span class="toc-content-text">选用算法的考虑因素</span></a></li><li class="toc-content-item toc-content-level-3"><a class="toc-content-link" href="#%E9%80%89%E7%94%A8%E7%AE%97%E6%B3%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%9C%BA%E6%99%AF"><span class="toc-content-text">选用算法的基本场景</span></a></li></ol></li><li class="toc-content-item toc-content-level-2"><a class="toc-content-link" href="#%E5%9F%BA%E4%BA%8E%E6%AF%94%E8%BE%83%E6%8E%92%E5%BA%8F%E7%9A%84%E5%88%86%E6%9E%90"><span class="toc-content-text">基于比较排序的分析</span></a></li></ol>
        
      </div>
    </section>


</div>
        <footer id="footer" class="footer">
  <div class="outer">
    <div class="copyright">
      <p><span>EXP Notes</span> &copy; 2015 - 2022</p>
    </div>
    <div class="navigation">
      <a href="https://evandoz.github.io">Hexo · Levan</a>
    </div>
  </div>
</footer>

      </div>
    </div>
  </div>
  
  <div id="mobile-nav" class="mobile-nav">
  
    <a class="menu-item" href="/Notes/archives">归档</a>
  
    <a class="menu-item" href="/Notes/categories">分类</a>
  
    <a class="menu-item" href="/Notes/tags">标签</a>
  
    <a class="menu-item" href="/Notes/about">关于</a>
  
</div>

<div id="over-layer" class="over-layer"></div>

  
<script src="/Notes/js/jquery.js"></script>


<script src="/Notes/js/velocity.js"></script>


<script src="/Notes/js/plugins.js"></script>


<script src="/Notes/js/script.js"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->




</body>
</html>
