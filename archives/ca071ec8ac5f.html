<!DOCTYPE html>
<html>
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  
  <title>图的最小生成树 | EXP Notes</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
    <meta name="author" content="Levan">
  
  
    <meta name="description" content="日常记录与分享">
  
  
    <meta name="keywords" content="数据结构,最小生成树">
  
  
    <meta name="google-site-verification" content="W2AVg5n_ALo21rl9n3ZwS8AuEanZfJkirzrRGLLYvn4">
  
  
    <meta name="baidu-site-verification" content="BM2Q3xLpPJ">
  
  
    <meta name="360-site-verification" content="573211edf2de02c99d7b255b2c56513c">
  
  
    <link rel="short icon" type="image/x-icon" href="/Notes/css/images/favicon.ico">
  
  <link rel="canonical" href="https://evandoz.github.io/Notes/archives/ca071ec8ac5f.html">
  
<link rel="stylesheet" href="/Notes/css/style.css">

<meta name="generator" content="Hexo 5.3.0"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head>

<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="overflow" class="overflow">
    <div id="hiddenbar" class="hiddenbar">
      <div id="wrapper" class="wrapper">
        <header id="header" class="header is-post">
  <div class="outer">
    <div class="logo">
      <a class="title" href="/Notes/">EXP Notes</a>
    </div>
    <div class="nav">
      <ul id="nav-icon" class="nav-icon">
        <li></li><li></li><li></li>
      </ul>
      <ul class="nav-menu">
        
          <li class="nav-item">
            <a href="/Notes/archives">归档</a>
          </li>
        
          <li class="nav-item">
            <a href="/Notes/categories">分类</a>
          </li>
        
          <li class="nav-item">
            <a href="/Notes/tags">标签</a>
          </li>
        
          <li class="nav-item">
            <a href="/Notes/about">关于</a>
          </li>
        
      </ul>
    </div>

  </div>
</header>

        <div id="content" class="content">
    <section class="article-header inner">
      <img src="/Notes/css/images/banner2.jpg" alt="banner">
      

      
  
  	<h1 class="post-title">图的最小生成树</h1>
  


      <div class="post-meta">
        <span class="post-date">
  <time datetime="2016-08-11T16:00:00.000Z">2016-08-12</time>
</span>

        
  <span class="post-category">
    <a class="category-link" href="/Notes/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a> · <a class="category-link" href="/Notes/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE/">图</a>
  </span>


      </div>
    </section>
    <section class="article-body inner">
      <div id="side" class="aside post left">

      </div>
      <div class="main">
        <article id="数据结构/图/20160812-图的最小生成树" class="article">
          <div id="post-content" class="post-content">
            <h2 id="基本概念"><a class="headerlink" href="#基本概念"></a>基本概念</h2>
<p>图的最小生成树问题在现实生活中有重要应用，譬如在 n 个城市之间搭建通信网。<br>
对于 n 个节点的连通图，可以建立很多不同的生成树，每个生成树都可以是一个通信网，要是通信网总的耗费最小（衡量标准根据具体情况而定，可能是距离、价格等等），就是要找到一棵最小生成树，这就是最小生成树问题(Minimum Cost Spanning Tree, MST)。一棵生成树的代价就是各边的代价之和。</p>
<h2 id="算法原理"><a class="headerlink" href="#算法原理"></a>算法原理</h2>
<p>构造生成树有很多算法，多数算法都用到一条 MST 的性质：</p>
<p>假设 N = (V, {E}) 是一个连通网，U 是顶点集 V 的一个非空子集，如果 (u, v) 是一条具有最小权值（代价）的边，其中 u∈U, v∈V-U，那么一定存在一棵包含边 (u, v) 的最小生成树。</p>
<p>该性质可以用反证法加以证明。</p>
<h2 id="普利姆算法-Prim"><a class="headerlink" href="#普利姆算法-Prim"></a>普利姆算法(Prim)</h2>
<h3 id="算法过程"><a class="headerlink" href="#算法过程"></a>算法过程</h3>
<p>假设 N = (V, {E}) 是连通网，TE 是 N 上最小生成树中变得合集。<br>
算法从 U = {u<sub>0</sub>}(u<sub>0</sub>∈V), TE = {} 开始，重复如下操作：<br>
在所有 u∈U, v∈V-U 的边 (u, v)∈E 中找一条代价最小的边 (u<sub>0</sub>, v<sub>0</sub>) 并入集合 TE，同时 v<sub>0</sub> 并入 U ，直至 U=V 为止。<br>
此时 TE 中必有 n-1 条边，则 T = (V, {TE}) 为 N 的最小生成树。</p>
<p>为了实现算法，需要一个辅助数组 <code>closedge</code>，用来<strong>记录从 U 到 V-U 具有最小代价的边</strong>。<br>
对每个顶点 v<sub>i</sub>∈V-U，在辅助数组中存在一个分量 closedge[i]，它包含两个域，<br>
其中 <code>lowcost域</code>  <strong>存储该边上的权</strong>，<code>vex 域</code> <strong>存储该边依附在 U 中的顶点</strong>。</p>
<h3 id="算法实现（邻接矩阵）"><a class="headerlink" href="#算法实现（邻接矩阵）"></a>算法实现（邻接矩阵）</h3>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// Prim</span>
<span class="token keyword">void</span> <span class="token function">MiniSpanTree_Prim</span><span class="token punctuation">(</span>MGraph <span class="token operator">*</span>G<span class="token punctuation">,</span> VertexType v<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> k<span class="token punctuation">;</span>
    ArcType minicost<span class="token punctuation">;</span>
    <span class="token comment">// 定义辅助数组，记录当前最小生成树与树外节点的最小距离及关联的树内顶点</span>
    <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
        VertexType adjvex<span class="token punctuation">;</span> <span class="token comment">// 用于复原</span>
        ArcType lowcost<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>closedge<span class="token punctuation">[</span>MAX_VERTEX_NUM<span class="token punctuation">]</span><span class="token punctuation">;</span>

    <span class="token comment">// 初始化 closedge</span>
    k <span class="token operator">=</span> <span class="token function">LocateVex</span><span class="token punctuation">(</span>G<span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> G<span class="token operator">-></span>vexnum<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>G<span class="token operator">-></span>vexs<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> v<span class="token punctuation">)</span>
            closedge<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>lowcost <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span>
        <span class="token punctuation">&#123;</span>
            closedge<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>adjvex <span class="token operator">=</span> v<span class="token punctuation">;</span>
            closedge<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>lowcost <span class="token operator">=</span> G<span class="token operator">-></span>arcs<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token comment">// Prim 算法运行 G->vexnum -1 次</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> G<span class="token operator">-></span>vexnum<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token comment">// 计算最小，得到k，k为最顶距离对应的节点（位置下标）</span>
        minicost <span class="token operator">=</span> INF<span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> G<span class="token operator">-></span>vexnum<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>closedge<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>lowcost <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> closedge<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>lowcost <span class="token operator">&lt;</span> minicost<span class="token punctuation">)</span>
            <span class="token punctuation">&#123;</span>
                minicost <span class="token operator">=</span> closedge<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>lowcost<span class="token punctuation">;</span>
                k <span class="token operator">=</span> j<span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c-[%d]-%c\t"</span><span class="token punctuation">,</span> closedge<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>adjvex<span class="token punctuation">,</span> G<span class="token operator">-></span>arcs<span class="token punctuation">[</span><span class="token function">LocateVex</span><span class="token punctuation">(</span>G<span class="token punctuation">,</span> closedge<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>adjvex<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">,</span> G<span class="token operator">-></span>vexs<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 将节点 G->vexs[k] 纳入生成树</span>
        closedge<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>lowcost <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token comment">// 更新 closedge</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> G<span class="token operator">-></span>vexnum<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>G<span class="token operator">-></span>arcs<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> closedge<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>lowcost<span class="token punctuation">)</span>
            <span class="token punctuation">&#123;</span>
                closedge<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>adjvex <span class="token operator">=</span> G<span class="token operator">-></span>vexs<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>
                closedge<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>lowcost <span class="token operator">=</span> G<span class="token operator">-></span>arcs<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="复杂度分析"><a class="headerlink" href="#复杂度分析"></a>复杂度分析</h3>
<p>算法实现中有两个内循环，第 1 个内循环是在 closedge 中选择 lowcost 最小值，时间为 O(n-1)；<br>
第 2 个内循环更新 closedge 中的 lowcost 和 vex，时间为 O(n)。</p>
<p>因此，普利姆算法时间复杂度为 <strong>O(n<sup>2</sup>)</strong>，与图的顶点数有关，而与图中的边数无关，所以适用于求 <strong>边稠密</strong> 的网的最小生成树。</p>
<h2 id="克鲁斯卡尔算法-Kruskal"><a class="headerlink" href="#克鲁斯卡尔算法-Kruskal"></a>克鲁斯卡尔算法(Kruskal)</h2>
<h3 id="算法过程-v2"><a class="headerlink" href="#算法过程-v2"></a>算法过程</h3>
<p>普利姆从顶点角度建立最小生成树，而克鲁斯卡尔算法则从边的角度求解。</p>
<p>假设连通网 N = (V, {E})，则令最小生成树的初始状态为 <strong>只有 n 个顶点而无边的非连通图 T = (V, {})</strong>，网中每个顶底啊都自成一个连通分量，在 E 中选择代价最小的边，如果该边依附的顶点落在 T 中不同的连通分量中，则将此边加入到 T 中，否则舍去选择下一条代价最小的边。<br>
依此类推，直到 T 中所有顶点都在同一个连通分量上为止。</p>
<p>连通分量可以用 <code>并查集 MFSet</code> 来表示，每一轮选择最小代价的边可以用 <code>堆</code> 来实现。</p>
<h3 id="算法实现（邻接矩阵）-v2"><a class="headerlink" href="#算法实现（邻接矩阵）-v2"></a>算法实现（邻接矩阵）</h3>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// Kruskal</span>
<span class="token keyword">void</span> <span class="token function">MiniSpanTree_Kruskal</span><span class="token punctuation">(</span>MGraph <span class="token operator">*</span>G<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token comment">// k 用于取当前权值最小边</span>
    <span class="token comment">// m, n 用于取顶点所在的连通分量</span>
    <span class="token keyword">int</span> i<span class="token punctuation">,</span> k <span class="token operator">=</span> G<span class="token operator">-></span>arcnum<span class="token punctuation">,</span> m<span class="token punctuation">,</span> n<span class="token punctuation">;</span>
    <span class="token keyword">int</span> AS<span class="token punctuation">[</span>MAX_VERTEX_NUM<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 用并查集表示连通分量</span>
    ArcHeap AH<span class="token punctuation">[</span>MAX_VERTEX_NUM<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 用边集堆选择最小权值边</span>
    <span class="token function">InitMFSet</span><span class="token punctuation">(</span>AS<span class="token punctuation">,</span> G<span class="token operator">-></span>vexnum<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">InitArcHeap</span><span class="token punctuation">(</span>AH<span class="token punctuation">,</span> G<span class="token operator">-></span>arcs<span class="token punctuation">,</span> G<span class="token operator">-></span>arcnum<span class="token punctuation">,</span> G<span class="token operator">-></span>vexnum<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> G<span class="token operator">-></span>arcnum<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        k <span class="token operator">=</span> <span class="token function">GetRoot</span><span class="token punctuation">(</span>AH<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>
        m <span class="token operator">=</span> <span class="token function">Fix_MFSet</span><span class="token punctuation">(</span>AS<span class="token punctuation">,</span> AH<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>vex_1<span class="token punctuation">)</span><span class="token punctuation">;</span>
        n <span class="token operator">=</span> <span class="token function">Fix_MFSet</span><span class="token punctuation">(</span>AS<span class="token punctuation">,</span> AH<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>vex_2<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 属于不同的连通分量，将其加入</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>m <span class="token operator">!=</span> n<span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
            <span class="token comment">// 合并连通分量</span>
            <span class="token function">Mix_MFSet</span><span class="token punctuation">(</span>AS<span class="token punctuation">,</span> m<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c-[%d]-%c\t"</span><span class="token punctuation">,</span> G<span class="token operator">-></span>vexs<span class="token punctuation">[</span>AH<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>vex_1<span class="token punctuation">]</span><span class="token punctuation">,</span> G<span class="token operator">-></span>arcs<span class="token punctuation">[</span>AH<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>vex_1<span class="token punctuation">]</span><span class="token punctuation">[</span>AH<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>vex_2<span class="token punctuation">]</span><span class="token punctuation">,</span> G<span class="token operator">-></span>vexs<span class="token punctuation">[</span>AH<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>vex_2<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token operator">--</span>k<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="复杂度分析-v2"><a class="headerlink" href="#复杂度分析-v2"></a>复杂度分析</h3>
<p>算法实现中至多对 e 条边各扫描一次，用堆来存放边，则每次选择除最小代价的边仅需要 O(loge) 的时间（第一次为 O(e)）；<br>
网中的连通分量是等价类，用并查集来描述，构造并查集需要 O(eloge) 的时间。</p>
<p>因此，克鲁斯卡尔算法时间复杂度为 <strong>O(eloge)</strong>，与图的顶点数无关，而与图的边数有关，所以适用于求 <strong>边稀疏</strong> 的网的最小生成树。</p>
<p>完整代码可参见：<a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/Evandoz/Data-Structures/tree/master/Graph/MGraph.h">GitHub</a></p>
<p><strong>DONE！</strong></p>

          </div>
          <div class="post-footer">
            <div class="post-copyright">&copy; 除特殊声明外，文章著作权归作者所有，转载请注明作者及出处</div>
          </div>
        </article>
        <!-- Pagination -->
        
          <div class="nagination card">
            
              <a href="/Notes/archives/a014cdddb11c" class="nagination-link">上篇: 图的关节点问题</a>
            
            
              <a href="/Notes/archives/e6c839ee0f6b" class="nagination-link">下篇: 有向图的强连通分量</a>
            
          </div>
        
        <!-- Comment -->
        <!-- 
          <div id="article-comment" class="article-comment card"></div>

         -->
      </div>
      <div id="toc" class="toc">
        
          <ol class="toc-content"><li class="toc-content-item toc-content-level-2"><a class="toc-content-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-content-text">基本概念</span></a></li><li class="toc-content-item toc-content-level-2"><a class="toc-content-link" href="#%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86"><span class="toc-content-text">算法原理</span></a></li><li class="toc-content-item toc-content-level-2"><a class="toc-content-link" href="#%E6%99%AE%E5%88%A9%E5%A7%86%E7%AE%97%E6%B3%95-Prim"><span class="toc-content-text">普利姆算法(Prim)</span></a><ol class="toc-content-child"><li class="toc-content-item toc-content-level-3"><a class="toc-content-link" href="#%E7%AE%97%E6%B3%95%E8%BF%87%E7%A8%8B"><span class="toc-content-text">算法过程</span></a></li><li class="toc-content-item toc-content-level-3"><a class="toc-content-link" href="#%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%EF%BC%88%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%EF%BC%89"><span class="toc-content-text">算法实现（邻接矩阵）</span></a></li><li class="toc-content-item toc-content-level-3"><a class="toc-content-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90"><span class="toc-content-text">复杂度分析</span></a></li></ol></li><li class="toc-content-item toc-content-level-2"><a class="toc-content-link" href="#%E5%85%8B%E9%B2%81%E6%96%AF%E5%8D%A1%E5%B0%94%E7%AE%97%E6%B3%95-Kruskal"><span class="toc-content-text">克鲁斯卡尔算法(Kruskal)</span></a><ol class="toc-content-child"><li class="toc-content-item toc-content-level-3"><a class="toc-content-link" href="#%E7%AE%97%E6%B3%95%E8%BF%87%E7%A8%8B-v2"><span class="toc-content-text">算法过程</span></a></li><li class="toc-content-item toc-content-level-3"><a class="toc-content-link" href="#%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%EF%BC%88%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%EF%BC%89-v2"><span class="toc-content-text">算法实现（邻接矩阵）</span></a></li><li class="toc-content-item toc-content-level-3"><a class="toc-content-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-v2"><span class="toc-content-text">复杂度分析</span></a></li></ol></li></ol>
        
      </div>
    </section>


</div>
        <footer id="footer" class="footer">
  <div class="outer">
    <div class="copyright">
      <p><span>EXP Notes</span> &copy; 2015 - 2022</p>
    </div>
    <div class="navigation">
      <a href="https://evandoz.github.io">Hexo · Levan</a>
    </div>
  </div>
</footer>

      </div>
    </div>
  </div>
  
  <div id="mobile-nav" class="mobile-nav">
  
    <a class="menu-item" href="/Notes/archives">归档</a>
  
    <a class="menu-item" href="/Notes/categories">分类</a>
  
    <a class="menu-item" href="/Notes/tags">标签</a>
  
    <a class="menu-item" href="/Notes/about">关于</a>
  
</div>

<div id="over-layer" class="over-layer"></div>

  
<script src="/Notes/js/jquery.js"></script>


<script src="/Notes/js/velocity.js"></script>


<script src="/Notes/js/plugins.js"></script>


<script src="/Notes/js/script.js"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->




</body>
</html>
