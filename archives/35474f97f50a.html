<!DOCTYPE html>
<html>
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  
  <title>二叉排序树 | EXP Notes</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
    <meta name="author" content="Levan">
  
  
    <meta name="description" content="日常记录与分享">
  
  
    <meta name="keywords" content="数据结构,二叉排序树,二叉查找树,Binary Sort Tree,BST">
  
  
    <meta name="google-site-verification" content="W2AVg5n_ALo21rl9n3ZwS8AuEanZfJkirzrRGLLYvn4">
  
  
    <meta name="baidu-site-verification" content="BM2Q3xLpPJ">
  
  
    <meta name="360-site-verification" content="573211edf2de02c99d7b255b2c56513c">
  
  
    <link rel="short icon" type="image/x-icon" href="/Notes/css/images/favicon.ico">
  
  <link rel="canonical" href="https://evandoz.github.io/Notes/archives/35474f97f50a.html">
  
<link rel="stylesheet" href="/Notes/css/style.css">

<meta name="generator" content="Hexo 5.3.0"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head>

<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="overflow" class="overflow">
    <div id="hiddenbar" class="hiddenbar">
      <div id="wrapper" class="wrapper">
        <header id="header" class="header is-post">
  <div class="outer">
    <div class="logo">
      <a class="title" href="/Notes/">EXP Notes</a>
    </div>
    <div class="nav">
      <ul id="nav-icon" class="nav-icon">
        <li></li><li></li><li></li>
      </ul>
      <ul class="nav-menu">
        
          <li class="nav-item">
            <a href="/Notes/archives">归档</a>
          </li>
        
          <li class="nav-item">
            <a href="/Notes/categories">分类</a>
          </li>
        
          <li class="nav-item">
            <a href="/Notes/tags">标签</a>
          </li>
        
          <li class="nav-item">
            <a href="/Notes/about">关于</a>
          </li>
        
      </ul>
    </div>

  </div>
</header>

        <div id="content" class="content">
    <section class="article-header inner">
      <img src="/Notes/css/images/banner2.jpg" alt="banner">
      

      
  
  	<h1 class="post-title">二叉排序树</h1>
  


      <div class="post-meta">
        <span class="post-date">
  <time datetime="2016-07-01T16:00:00.000Z">2016-07-02</time>
</span>

        
  <span class="post-category">
    <a class="category-link" href="/Notes/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a> · <a class="category-link" href="/Notes/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%9F%A5%E6%89%BE%E8%A1%A8/">查找表</a>
  </span>


      </div>
    </section>
    <section class="article-body inner">
      <div id="side" class="aside post left">

      </div>
      <div class="main">
        <article id="数据结构/查找表/20160702-二叉排序树" class="article">
          <div id="post-content" class="post-content">
            <h2 id="二叉排序树"><a class="headerlink" href="#二叉排序树"></a>二叉排序树</h2>
<p>二叉排序树(Binary Sort Tree)或者是一棵空树，或者是具有如下性质的非空二叉树：<br>
(1) 若其左子树不空，则左子树上<strong>所有</strong>节点的值<strong>均小于</strong>它的根节点的值；<br>
(2) 若其右子树不空，则右子树上<strong>所有</strong>节点的值<strong>均大于</strong>它的根节点的值；<br>
(3) 其左、右子树也分别是二叉排序树。</p>
<p>可见，二叉排序树是一个递归的数据结构，可以方便地使用递归算法对二叉排序树进行各种运算。此外，根据定义可知</p>
<p>$$ 左子树节点值 &lt; 根节点值 &lt; 右子树节点值 $$</p>
<p>因此，对二叉排序树进行<strong>中序遍历</strong>，可以得到一个<strong>递增</strong>的有序序列，<strong>序列中不存在相等的元素</strong>。</p>
<h2 id="二叉排序树的查找"><a class="headerlink" href="#二叉排序树的查找"></a>二叉排序树的查找</h2>
<p>二叉排序树（查找树）的查找从根节点开始，沿着某一分支向下进行比较。<br>
若二叉排序树非空，先将给定值与根节点关键字比较，若相等则成功；<br>
若不等，当给定值小于根节点关键字时，在根节点左子树中查找；<br>
否则，当给定值大于根节点关键字时，在根节点右子树中查找；<br>
显然，这是个递归的过程。<br>
用二叉链表作为二叉排序树的存储结构，则该查找过程的算法实现如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">BSTree <span class="token function">SearchBST_Recursion</span><span class="token punctuation">(</span>BSTree T<span class="token punctuation">,</span> TElemType key<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>T <span class="token operator">==</span> <span class="token constant">NULL</span> <span class="token operator">||</span> key <span class="token operator">==</span> T<span class="token operator">-></span>data<span class="token punctuation">)</span> <span class="token keyword">return</span> T<span class="token punctuation">;</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">&lt;</span> T<span class="token operator">-></span>data<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token function">SearchBST</span><span class="token punctuation">(</span>T<span class="token operator">-></span>lchild<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span> <span class="token keyword">return</span> <span class="token function">SearchBST</span><span class="token punctuation">(</span>T<span class="token operator">-></span>rchild<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>也可以用非递归来实现：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">BSTree <span class="token function">SearchBST_Non_Recursion</span><span class="token punctuation">(</span>BSTree T<span class="token punctuation">,</span> TElemType key<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    BSTNode <span class="token operator">*</span>p <span class="token operator">=</span> T<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">&amp;&amp;</span> p<span class="token operator">-></span>data <span class="token operator">!=</span> key<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">&lt;</span> p<span class="token operator">-></span>data<span class="token punctuation">)</span> p <span class="token operator">=</span> p<span class="token operator">-></span>lchild<span class="token punctuation">;</span>
        <span class="token keyword">else</span> p <span class="token operator">=</span> p<span class="token operator">-></span>rchild<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> p<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="二叉排序树的插入"><a class="headerlink" href="#二叉排序树的插入"></a>二叉排序树的插入</h2>
<p>二叉排序树是动态查找表，它的树结构通常不是一次性生成的，而是在查找过程中，当树中不存在关键字值等于给定值的节点时再进行插入。<br>
新插入的节点一定是一个新添加的<strong>叶子节点</strong>，并且是查找不成功时<strong>查找路径上最后一个访问的节点</strong>的<strong>孩子节点</strong></p>
<p>可见，插入过程也需要进行查找，可以到待查值时，则返回所得节点；没有找到时，ze返回最后一个访问的节点，以便进行后续插入<br>
为了能在查找失败时，返回最后一个访问的节点，在查找过程中需要一个指针 f 记录一下上一个访问的节点，即当前访问节点的双亲，起始 f = NULL。</p>
<p>因此，对之前的查找进行修改，增加一个指针 f 指向上一个访问的节点（双亲）</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// 返回值修改为布尔量，标识是否找到待查值，由 p 指向返回的节点</span>
Status <span class="token function">SearchBST_Non_Recursion</span><span class="token punctuation">(</span>BSTree T<span class="token punctuation">,</span> TElemType key<span class="token punctuation">,</span> BSTree <span class="token operator">*</span>p<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    BSTNode <span class="token operator">*</span>f <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token operator">*</span>t <span class="token operator">=</span> T<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>t <span class="token operator">&amp;&amp;</span> key <span class="token operator">!=</span> t<span class="token operator">-></span>data<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        f <span class="token operator">=</span> t<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">&lt;</span> t<span class="token operator">-></span>data<span class="token punctuation">)</span>  t <span class="token operator">=</span> t<span class="token operator">-></span>lchild<span class="token punctuation">;</span>
        <span class="token keyword">else</span> t <span class="token operator">=</span> t<span class="token operator">-></span>rchild<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span> <span class="token operator">=</span> t<span class="token punctuation">;</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token comment">// 找到</span>
    <span class="token keyword">else</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span> <span class="token operator">=</span> f<span class="token punctuation">;</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token comment">// 未找到</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>于是二叉排序树的插入算法如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">Status <span class="token function">InsertBST</span><span class="token punctuation">(</span>BSTree <span class="token operator">*</span>T<span class="token punctuation">,</span> TElemType key<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    BSTNode <span class="token operator">*</span>p<span class="token punctuation">,</span> <span class="token operator">*</span>s<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">0</span> <span class="token operator">==</span> <span class="token function">SearchBST_Non_Recursion</span><span class="token punctuation">(</span><span class="token operator">*</span>T<span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token operator">&amp;</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token comment">// 生成新结点</span>
        s <span class="token operator">=</span> <span class="token punctuation">(</span>BSTNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>BSTNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        s<span class="token operator">-></span>data <span class="token operator">=</span> key<span class="token punctuation">;</span> s<span class="token operator">-></span>lchild <span class="token operator">=</span> s<span class="token operator">-></span>rchild <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
        <span class="token comment">// 插入</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">*</span>T<span class="token punctuation">)</span> <span class="token operator">=</span> s<span class="token punctuation">;</span> <span class="token comment">// 空树</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">&lt;</span> p<span class="token operator">-></span>data<span class="token punctuation">)</span> p<span class="token operator">-></span>lchild <span class="token operator">=</span> s<span class="token punctuation">;</span>
        <span class="token keyword">else</span> p<span class="token operator">-></span>rchild <span class="token operator">=</span> s<span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">else</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="二叉排序树的构造"><a class="headerlink" href="#二叉排序树的构造"></a>二叉排序树的构造</h2>
<p>二叉排序树是动态查找表，构造一棵二叉排序树就是不断插入新节点的过程，因此**二叉排序树中一定没有相同元素，**这符合二叉排序树的定义。<br>
根据二叉排序树性质，中序遍历可以得到一个递增的有序序列，也就是说一个无序序列可以通过构造二叉排序树变成一个有序序列，构造树的过程也就是排序过程。<br>
因为插入操作均发生在叶子节点，它不需要移动其他节点，只需要修改指针，这就相当于在有序序列上插入一个新元素却不需要移动其他元素，<br>
可见，<strong>二叉排序树既能像顺序表一样进行折半查找（类似），又能进行链式结构的插入操作，不需要大量移动元素</strong>，因此二叉排序树是动态查找表一种经典实用的表示方式。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// 通过节点插入新建一棵二叉树</span>
Status <span class="token function">InitBST</span><span class="token punctuation">(</span>BSTree <span class="token operator">*</span>T<span class="token punctuation">,</span> TElemType <span class="token operator">*</span>key<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> i<span class="token punctuation">;</span>
    <span class="token punctuation">(</span><span class="token operator">*</span>T<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token function">InsertBST</span><span class="token punctuation">(</span>T<span class="token punctuation">,</span> key<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="二叉排序树的删除"><a class="headerlink" href="#二叉排序树的删除"></a>二叉排序树的删除</h2>
<p>在二叉排序树中删除一个节点时，不能把以该节点为根的子树上的所有节点都删除，只能删除这个节点本身，然后将其断开的子树重新链接到原来的排序上，并且要确保重新链接的排序树的性质特性不会丢失。<br>
二叉排序树的性质与中序遍历序列紧密相关，因此要确保重新链接的排序树特性不丢失，可以从中序遍历的角度思考，即用删除节点的中序前驱或后继顶替她原本的位置即可。</p>
<p>具体地，有如下三种情形：<br>
(1) 被删除节点 p 是叶子节点，则直接删除即可；<br>
(2) 被删除节点 p 只有左或右子树，则让它的子树顶替它的位置，即让它的子树链接到它的双亲；<br>
(3) 被删除节点 p 有左、右子树，则让它的<strong>直接中序前驱或后继顶替它的位置</strong>，然后删除该前驱或后继；</p>
<p>(Ⅰ) <strong>用前驱顶替</strong>，即用其左子树最右下节点 s 顶替 p，由于 s 没有右子树，所以只需再将 s 的左子树链接到 s 的双亲上，最后删除 s；<br>
处理一个特殊情形：p 的左孩子就是其前驱 s，即 p 的左孩子没有右子树，这是(2)的场景，按(2)处理即可；<br>
(Ⅱ) <strong>用后继顶替</strong>，即用其右子树最左下节点 s 顶替 p，由于 s 没有左子树，所以只需再将 s 的右子树链接到 s 的双亲上，最后删除 s；<br>
处理一个特殊情形：p 的左孩子就是其前驱 s，即 p 的右孩子没有左子树，这是(2)的场景，按(2)处理即可；</p>
<p>可见，前驱顶替和后继顶替的操作是刚好对称的。</p>
<p><strong>除了用直接前驱或后继替换外，还有其他思路也能完成删除操作，譬如</strong></p>
<blockquote>
<p>将待删除节点 p 的左子树链接到它的双亲 f 顶替自己，而将 p 的右子树链接到 p 直接前驱 s，作为 s 的右子树。</p>
</blockquote>
<p>根据中序操作的对称性，也可以用右子树顶替自己。</p>
<p><strong>技巧：在进行子树或节点移动使，可以直接将子树当作节点处理，原因在于二叉排序树是一个递归结构，排序子树的内部结构不会因为（其双亲）根节点被删除而破坏。</strong></p>
<pre class="line-numbers language-none"><code class="language-none">void Delete(BSTree *p)
&#123;
    BSTNode *q, *s;
    &#x2F;&#x2F; 右空用左顶替
    if ((*p)-&gt;rchild &#x3D;&#x3D; NULL)
    &#123;
        q &#x3D; (*p); (*p) &#x3D; (*p)-&gt;lchild; free(q);
    &#125;
    &#x2F;&#x2F; 左空用右顶替
    else if ((*p)-&gt;lchild &#x3D;&#x3D; NULL)
    &#123;
        q &#x3D; (*p); (*p) &#x3D; (*p)-&gt;rchild; free(q);
    &#125;
    &#x2F;&#x2F; 左右都不空
    else
    &#123;
        q &#x3D; *p; s &#x3D; (*p)-&gt;lchild;
        &#x2F;&#x2F; 左子树右下找前驱
        while(s-&gt;rchild)
        &#123;
            q &#x3D; s;
            s &#x3D; s-&gt;rchild;
        &#125;
        &#x2F;&#x2F; s 顶替 p
        (*p)-&gt;data &#x3D; s-&gt;data;
        &#x2F;&#x2F; 处理特殊情形
        if (q &#x3D;&#x3D; (*p))
            q-&gt;lchild &#x3D; s-&gt;lchild;
        &#x2F;&#x2F; 处理一般情形
        else
            q-&gt;rchild &#x3D; s-&gt;lchild;
        free(s);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>另一种思路：(2)(3)可以合并</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">Delete_2</span><span class="token punctuation">(</span>BSTree <span class="token operator">*</span>p<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    BSTNode <span class="token operator">*</span>q<span class="token punctuation">,</span> <span class="token operator">*</span>s<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token operator">-></span>rchild <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        q <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token operator">-></span>lchild<span class="token punctuation">;</span> <span class="token function">free</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">else</span>
    <span class="token punctuation">&#123;</span>
        <span class="token comment">// 左树右下找 p 的前驱 s</span>
        q <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span> s <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token operator">-></span>lchild<span class="token punctuation">;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>s<span class="token operator">-></span>rchild<span class="token punctuation">)</span>
            s <span class="token operator">=</span> s<span class="token operator">-></span>rchild<span class="token punctuation">;</span>
        <span class="token comment">// (*p) 的右子树作为 s 的右子树</span>
        s<span class="token operator">-></span>rchild <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token operator">-></span>rchild<span class="token punctuation">;</span>
        <span class="token comment">// (*p) 的左孩子顶替自己</span>
        <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token operator">-></span>lchild<span class="token punctuation">;</span>
        <span class="token function">free</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>关于删除再插入的问题：</strong><br>
如果在二叉排序树中先删除再插入一个节点，得到的排序树是否与原来相同？<br>
答案是<strong>不一定</strong>！！原因在于<strong>删除</strong>操作可以发生在<strong>叶子节点和非叶子节点</strong>，而<strong>插入</strong>操作只发生在<strong>叶子节点</strong>，如果删除和插入的位置不同，得到的树也一定与之前不同。<br>
当被删除节点是非叶子节点，那么重新插入时该节点就成了叶子节点，显然前后两个二叉树不一样；<br>
但是，还需要注意的是，<strong>虽然树结构不同，但是中序序列是相同的</strong>，这是由二叉排序树的特性决定的。</p>
<h2 id="二叉排序树的查找分析"><a class="headerlink" href="#二叉排序树的查找分析"></a>二叉排序树的查找分析</h2>
<p>和折半查找类似，二叉排序树的进行查找比较的次数不超过树的深度 h，不过折半查找长度为 n 的表的判定树是唯一的，而含有 n 个节点的二叉排序树却不是唯一的，相同的关键字插入的顺序（时间点）不同就可能生成不同的二叉排序树。</p>
<p>因此不同的二叉排序树，它的平均查找长度也就不同。也就是说，<strong>含有 n 个节点的二叉排序树，它的平均查找长度和树的形态有关。</strong></p>
<p>最坏的情况下，先后插入的关键字有序时，构造出的二叉排序树就蜕变成一棵单支树，树的深度增加为元素数量 n，平均查找长度为 \(\frac {n+1}{2}\)；<br>
最好的情况下，二叉排序树的形态和折半查找判定树相同，这时平均查找长度和 \(\log_2 n\) 成正比。</p>
<p>随机的情况下，二叉排序树的平均查找长度和 \(\log_2 n\) 是等数量级的，但在某些情况下，尚需要在构成二叉排序树的过程中进行“平衡化”操作，得到<strong>二叉平衡树</strong>。</p>
<p><strong>与折半查找对比（二分查找）：</strong></p>
<p>就维护查找表的有序性而言，二叉排序树进行插入和删除时，不需要移动节点，只需要修改指针，平均执行时间为 \(O(\log_2 n)\)；<br>
折半查找的存储结构是顺序表，进行插入和删除时，需要（大量）移动节点，需要的代价时 \(O(n)\)。</p>
<p>静态查找表，宜采用顺序表作为存储结构，使用折半查找策略；<br>
动态查找表，宜采用二叉排序树作为逻辑结构。</p>

          </div>
          <div class="post-footer">
            <div class="post-copyright">&copy; 除特殊声明外，文章著作权归作者所有，转载请注明作者及出处</div>
          </div>
        </article>
        <!-- Pagination -->
        
          <div class="nagination card">
            
              <a href="/Notes/archives/c8e55fe74f5a" class="nagination-link">上篇: 平衡二叉树</a>
            
            
              <a href="/Notes/archives/b1d00a9d5fae" class="nagination-link">下篇: 回溯法与树的遍历</a>
            
          </div>
        
        <!-- Comment -->
        <!-- 
          <div id="article-comment" class="article-comment card"></div>

         -->
      </div>
      <div id="toc" class="toc">
        
          <ol class="toc-content"><li class="toc-content-item toc-content-level-2"><a class="toc-content-link" href="#%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91"><span class="toc-content-text">二叉排序树</span></a></li><li class="toc-content-item toc-content-level-2"><a class="toc-content-link" href="#%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E7%9A%84%E6%9F%A5%E6%89%BE"><span class="toc-content-text">二叉排序树的查找</span></a></li><li class="toc-content-item toc-content-level-2"><a class="toc-content-link" href="#%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E7%9A%84%E6%8F%92%E5%85%A5"><span class="toc-content-text">二叉排序树的插入</span></a></li><li class="toc-content-item toc-content-level-2"><a class="toc-content-link" href="#%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E7%9A%84%E6%9E%84%E9%80%A0"><span class="toc-content-text">二叉排序树的构造</span></a></li><li class="toc-content-item toc-content-level-2"><a class="toc-content-link" href="#%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E7%9A%84%E5%88%A0%E9%99%A4"><span class="toc-content-text">二叉排序树的删除</span></a></li><li class="toc-content-item toc-content-level-2"><a class="toc-content-link" href="#%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E7%9A%84%E6%9F%A5%E6%89%BE%E5%88%86%E6%9E%90"><span class="toc-content-text">二叉排序树的查找分析</span></a></li></ol>
        
      </div>
    </section>


</div>
        <footer id="footer" class="footer">
  <div class="outer">
    <div class="copyright">
      <p><span>EXP Notes</span> &copy; 2015 - 2022</p>
    </div>
    <div class="navigation">
      <a href="https://evandoz.github.io">Hexo · Levan</a>
    </div>
  </div>
</footer>

      </div>
    </div>
  </div>
  
  <div id="mobile-nav" class="mobile-nav">
  
    <a class="menu-item" href="/Notes/archives">归档</a>
  
    <a class="menu-item" href="/Notes/categories">分类</a>
  
    <a class="menu-item" href="/Notes/tags">标签</a>
  
    <a class="menu-item" href="/Notes/about">关于</a>
  
</div>

<div id="over-layer" class="over-layer"></div>

  
<script src="/Notes/js/jquery.js"></script>


<script src="/Notes/js/velocity.js"></script>


<script src="/Notes/js/plugins.js"></script>


<script src="/Notes/js/script.js"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->




</body>
</html>
