<!DOCTYPE html>
<html>
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  
  <title>插入排序（一） | EXP Notes</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
    <meta name="author" content="Levan">
  
  
    <meta name="description" content="日常记录与分享">
  
  
    <meta name="keywords" content="插入排序,直接插入排序,2-路插入排序">
  
  
    <meta name="google-site-verification" content="W2AVg5n_ALo21rl9n3ZwS8AuEanZfJkirzrRGLLYvn4">
  
  
    <meta name="baidu-site-verification" content="BM2Q3xLpPJ">
  
  
    <meta name="360-site-verification" content="573211edf2de02c99d7b255b2c56513c">
  
  
    <link rel="short icon" type="image/x-icon" href="/Notes/css/images/favicon.ico">
  
  <link rel="canonical" href="https://evandoz.github.io/Notes/archives/148ac2b25397.html">
  
<link rel="stylesheet" href="/Notes/css/style.css">

<meta name="generator" content="Hexo 5.3.0"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head>

<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="overflow" class="overflow">
    <div id="hiddenbar" class="hiddenbar">
      <div id="wrapper" class="wrapper">
        <header id="header" class="header is-post">
  <div class="outer">
    <div class="logo">
      <a class="title" href="/Notes/">EXP Notes</a>
    </div>
    <div class="nav">
      <ul id="nav-icon" class="nav-icon">
        <li></li><li></li><li></li>
      </ul>
      <ul class="nav-menu">
        
          <li class="nav-item">
            <a href="/Notes/archives">归档</a>
          </li>
        
          <li class="nav-item">
            <a href="/Notes/categories">分类</a>
          </li>
        
          <li class="nav-item">
            <a href="/Notes/tags">标签</a>
          </li>
        
          <li class="nav-item">
            <a href="/Notes/about">关于</a>
          </li>
        
      </ul>
    </div>

  </div>
</header>

        <div id="content" class="content">
    <section class="article-header inner">
      <img src="/Notes/css/images/banner2.jpg" alt="banner">
      

      
  
  	<h1 class="post-title">插入排序（一）</h1>
  


      <div class="post-meta">
        <span class="post-date">
  <time datetime="2016-09-08T16:00:00.000Z">2016-09-09</time>
</span>

        
  <span class="post-category">
    <a class="category-link" href="/Notes/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a> · <a class="category-link" href="/Notes/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8E%92%E5%BA%8F/">排序</a>
  </span>


      </div>
    </section>
    <section class="article-body inner">
      <div id="side" class="aside post left">

      </div>
      <div class="main">
        <article id="数据结构/排序/20160909-插入排序（一）" class="article">
          <div id="post-content" class="post-content">
            <h2 id="基本概念"><a class="headerlink" href="#基本概念"></a>基本概念</h2>
<p>一种简单直观的排序方法，基本思想是 每一次将一个待排序的元素，按照大小插入到前面已排好序的子序列中去，知道全部元素排序完成，这样的操作称为<strong>插入排序</strong>，包括<strong>直接插入排序</strong>和<strong>希尔排序</strong>等。</p>
<h2 id="直接插入排序（Straight-Insertion-Sort）"><a class="headerlink" href="#直接插入排序（Straight-Insertion-Sort）"></a>直接插入排序（Straight Insertion Sort）</h2>
<h3 id="基本思想"><a class="headerlink" href="#基本思想"></a>基本思想</h3>
<p>将待排序列分为无序序列和有序序列两部分，然后依次将无序区的第一个元素按大小顺序插入到有序区中去，每次比较插入，无序区减1，有序区加1，最终将所有无序区元素都移动到有序区完成排序。</p>
<p>具体地，先将序列的第1个记录看成是一个有序的子序列，然后从第2个记录逐个进行插入，直至整个序列有序为止。</p>
<p>要点：设立哨兵，作为临时存储和判断数组边界之用。</p>
<h3 id="代码实现"><a class="headerlink" href="#代码实现"></a>代码实现</h3>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">InsertSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> L<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> i<span class="token punctuation">,</span> j<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span>n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token comment">// 起始首位置1（0号为哨兵）为有序部分，剩下n-1为待排序部分</span>
    <span class="token punctuation">&#123;</span>
        L<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> L<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// L[0]既为哨兵，又起到临时存储作用</span>
        <span class="token comment">// 因为L[0]位置即为当前待插入元素，因此当判断到L[0]时，循环必将结束，</span>
        <span class="token comment">// 不必考虑数组越界问题，即为哨兵作用</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> L<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> L<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token operator">--</span>j<span class="token punctuation">)</span> <span class="token comment">// 在有序部分中为L[i]找位置</span>
            L<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> L<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 元素后移</span>
        L<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> L<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 第j位时退出循环，此时应插入到j+1，原j+1位已空出</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="归纳分析"><a class="headerlink" href="#归纳分析"></a>归纳分析</h3>
<ol>
<li>稳定排序（stable sort）</li>
</ol>
<p>如果碰见一个和插入元素相等的，那么插入元素把想插入的元素放在相等元素的后面。所以，相等元素的前后顺序没有改变，从原无序序列出去的顺序就是排好序后的顺序，所以插入排序是 <strong>稳定排序</strong> 。</p>
<ol start="2">
<li>空间复杂度（in-place 原地算法，O(1)）</li>
</ol>
<p>需要一个辅助空间暂存元素，直接插入排序的空间复杂度为 O(1)。</p>
<ol start="3">
<li>时间复杂度</li>
</ol>
<p>比较和移动操作一块进行；</p>
<p><strong>最好</strong>情况下，时间复杂度为 O(n)，此时待排序列原本有序。</p>
<p><strong>最坏</strong>情况下，时间复杂度为 O(n<sup>2</sup>)，此时待排序列刚好逆序。</p>
<p>考虑哨兵的比较，比较次数为 Σi= (n+2)(n-1)/2，（i = {2,…,n}）<br>
不考虑哨兵的比较，比较次数为 Σi - (n-1)= n(n-1)/2, i = {2,…,n}，</p>
<p>移动次数为 Σ(i+1)= (n+4)(n-1)/2，（i = {2,…,n}）。</p>
<p>插入排序的时间复杂度与逆序对的数量保持一致，当数组倒序时，逆序对的个数为n(n-1)/2，因此插入排序复杂度为O(n<sup>2</sup>)。</p>
<p><strong>平均</strong>情况下，直接插入排序的时间复杂度为 O(n<sup>2</sup>)。</p>
<ol start="4">
<li>初态影响</li>
</ol>
<p>由3中分析，时间复杂度 <strong>与初始状态有关</strong></p>
<ol start="5">
<li>过程特征</li>
</ol>
<p>一趟排序不能确定一个元素的最终位置，但会产生<strong>局部有序</strong>的有序子序列。</p>
<p><strong>局部有序</strong>：有序序列中的元素与无序序列中的元素大小关系未知。</p>
<p>根据插入排序的原理，插入排序会产生有序子序列，但只是*<strong>局部有序</strong>；</p>
<p>插入排序<strong>不到最后一趟排序，每个元素都有可能不在其最终的位置上</strong>，一个极端的例子是，最后一趟排序是将最后一个元素插入到有序序列的第一个位置上，这样一来，在最后一趟排序之前，所有元素都不在其最终位置上。</p>
<ol start="6">
<li>适用性</li>
</ol>
<p>插入排序比较适合用于“基本有序”的序列和“数据量不大（不大于50）”的序列，不过因为直接插入排序移动操作比较多，所以不太适合元素本身信息量较大的情况，可用冒泡排序。</p>
<h3 id="算法证明（来自算法导论）"><a class="headerlink" href="#算法证明（来自算法导论）"></a>算法证明（来自算法导论）</h3>
<p>循环不变式：在每次循环开始前，A[1…i-1]包含了原来的A[1…i-1]的元素，并且已排序。</p>
<p>初始：i=2，A[1…1]已排序，成立。<br>
保持：在迭代开始前，A[1…i-1]已排序，而循环体的目的是将A[i]插入A[1…i-1]中，使得A[1…i]排序，因此在下一轮迭代开       始前，i++，因此现在A[1…i-1]排好序了，因此保持循环不变式。<br>
终止：最后i=n+1，并且A[1…n]已排序，而A[1…n]就是整个数组，因此证毕。</p>
<h3 id="其他问题"><a class="headerlink" href="#其他问题"></a>其他问题</h3>
<ul>
<li>代码 7-8 行能否用用二分法实现？</li>
</ul>
<p>不能。因为第 7-8 行并不是单纯的线性查找，而是还要移出一个空位让A[i]插入，即，比较和移动操作是一起的，因此就算二分查找用 O(logn) 查到了插入的位置，但还是要用 O(n) 的时间移出一个空位，这就是折半插入排序。</p>
<ul>
<li>快速排序（不使用随机化）是否一定比插入排序快？</li>
</ul>
<p>不一定。最好情况下，待排序列原本有序，插入排序需要 O(n) 时间，而快速排序需要 O(n<sup>2</sup>) 时间。</p>
<h2 id="折半插入排序（Binary-Insertion-Sort）"><a class="headerlink" href="#折半插入排序（Binary-Insertion-Sort）"></a>折半插入排序（Binary Insertion Sort）</h2>
<h3 id="基本思想-v2"><a class="headerlink" href="#基本思想-v2"></a>基本思想</h3>
<p>之前的直接插入排序是一边比较一边移动，现在将比较和移动操作分离，先用折半查找得到待插入位置，然后统一移动；</p>
<p>因此，折半插入排序仅仅减少了比较次数，时间复杂度为 O(nlogn)，其与初始状态无关，仅取决于元素个数 n；</p>
<p>但移动次数不变，时间复杂度为 O(n<sup>2</sup>)，其仍然与初始状态有关，因此，时间复杂度仍为 O(n<sup>2</sup>)</p>
<h3 id="代码实现-v2"><a class="headerlink" href="#代码实现-v2"></a>代码实现</h3>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">BInsertSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> L<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> low<span class="token punctuation">,</span> high<span class="token punctuation">,</span> mid<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        low <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> high <span class="token operator">=</span> i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>low <span class="token operator">&lt;=</span> high<span class="token punctuation">)</span> <span class="token comment">// 查找，循环中满足L[low]&lt;=L[0]&lt;=L[high]</span>
        <span class="token punctuation">&#123;</span>
            mid <span class="token operator">=</span> <span class="token punctuation">(</span>low <span class="token operator">+</span> high<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>L<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> L<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span> high <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 左半</span>
            <span class="token keyword">else</span> low <span class="token operator">=</span> mid <span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 右半）</span>
        <span class="token punctuation">&#125;</span> <span class="token comment">// 退出时low-high=1，应当插在high+1的位置</span>
        L<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> L<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> i<span class="token punctuation">;</span> j <span class="token operator">></span> high<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token operator">--</span>j<span class="token punctuation">)</span> <span class="token comment">// 移动</span>
            L<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> L<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        L<span class="token punctuation">[</span>high<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> L<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="归纳分析-v2"><a class="headerlink" href="#归纳分析-v2"></a>归纳分析</h3>
<ol>
<li>稳定排序（stable sort）</li>
</ol>
<p>仍是插入排序，仅在比较查找时进行了折半查找优化，移动操作不变，因此仍是 <strong>稳定排序</strong> 。</p>
<ol start="2">
<li>空间复杂度（in-place 原地算法，O(1)）</li>
</ol>
<p>需要一个辅助空间暂存元素，折半插入排序的空间复杂度为 O(1)。</p>
<ol start="3">
<li>时间复杂度</li>
</ol>
<p>比较和移动操作分离；</p>
<p>减少了比较操作的次数，移动操作次数不变；</p>
<p><strong>平均</strong>情况下，折半插入排序的时间复杂度为 O(n<sup>2</sup>)。</p>
<ol start="4">
<li>初态影响</li>
</ol>
<p>比较次数减少，时间复杂度为 O(nlogn)，与初始状态无关；<br>
移动次数不变，时间复杂度为 O(n<sup>2</sup>)，与初始状态有关。</p>
<ol start="5">
<li>适用性</li>
</ol>
<p>折半插入仅针对顺序存储优化，<strong>只适用于顺序存储</strong> 的线性表。</p>

          </div>
          <div class="post-footer">
            <div class="post-copyright">&copy; 除特殊声明外，文章著作权归作者所有，转载请注明作者及出处</div>
          </div>
        </article>
        <!-- Pagination -->
        
          <div class="nagination card">
            
              <a href="/Notes/archives/289a8518ac6a" class="nagination-link">上篇: 交换排序（二）</a>
            
            
              <a href="/Notes/archives/a0eb34b48fe3" class="nagination-link">下篇: 插入排序（二）</a>
            
          </div>
        
        <!-- Comment -->
        <!-- 
          <div id="article-comment" class="article-comment card"></div>

         -->
      </div>
      <div id="toc" class="toc">
        
          <ol class="toc-content"><li class="toc-content-item toc-content-level-2"><a class="toc-content-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-content-text">基本概念</span></a></li><li class="toc-content-item toc-content-level-2"><a class="toc-content-link" href="#%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%EF%BC%88Straight-Insertion-Sort%EF%BC%89"><span class="toc-content-text">直接插入排序（Straight Insertion Sort）</span></a><ol class="toc-content-child"><li class="toc-content-item toc-content-level-3"><a class="toc-content-link" href="#%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3"><span class="toc-content-text">基本思想</span></a></li><li class="toc-content-item toc-content-level-3"><a class="toc-content-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-content-text">代码实现</span></a></li><li class="toc-content-item toc-content-level-3"><a class="toc-content-link" href="#%E5%BD%92%E7%BA%B3%E5%88%86%E6%9E%90"><span class="toc-content-text">归纳分析</span></a></li><li class="toc-content-item toc-content-level-3"><a class="toc-content-link" href="#%E7%AE%97%E6%B3%95%E8%AF%81%E6%98%8E%EF%BC%88%E6%9D%A5%E8%87%AA%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%EF%BC%89"><span class="toc-content-text">算法证明（来自算法导论）</span></a></li><li class="toc-content-item toc-content-level-3"><a class="toc-content-link" href="#%E5%85%B6%E4%BB%96%E9%97%AE%E9%A2%98"><span class="toc-content-text">其他问题</span></a></li></ol></li><li class="toc-content-item toc-content-level-2"><a class="toc-content-link" href="#%E6%8A%98%E5%8D%8A%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%EF%BC%88Binary-Insertion-Sort%EF%BC%89"><span class="toc-content-text">折半插入排序（Binary Insertion Sort）</span></a><ol class="toc-content-child"><li class="toc-content-item toc-content-level-3"><a class="toc-content-link" href="#%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3-v2"><span class="toc-content-text">基本思想</span></a></li><li class="toc-content-item toc-content-level-3"><a class="toc-content-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-v2"><span class="toc-content-text">代码实现</span></a></li><li class="toc-content-item toc-content-level-3"><a class="toc-content-link" href="#%E5%BD%92%E7%BA%B3%E5%88%86%E6%9E%90-v2"><span class="toc-content-text">归纳分析</span></a></li></ol></li></ol>
        
      </div>
    </section>


</div>
        <footer id="footer" class="footer">
  <div class="outer">
    <div class="copyright">
      <p><span>EXP Notes</span> &copy; 2015 - 2022</p>
    </div>
    <div class="navigation">
      <a href="https://evandoz.github.io">Hexo · Levan</a>
    </div>
  </div>
</footer>

      </div>
    </div>
  </div>
  
  <div id="mobile-nav" class="mobile-nav">
  
    <a class="menu-item" href="/Notes/archives">归档</a>
  
    <a class="menu-item" href="/Notes/categories">分类</a>
  
    <a class="menu-item" href="/Notes/tags">标签</a>
  
    <a class="menu-item" href="/Notes/about">关于</a>
  
</div>

<div id="over-layer" class="over-layer"></div>

  
<script src="/Notes/js/jquery.js"></script>


<script src="/Notes/js/velocity.js"></script>


<script src="/Notes/js/plugins.js"></script>


<script src="/Notes/js/script.js"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->




</body>
</html>
