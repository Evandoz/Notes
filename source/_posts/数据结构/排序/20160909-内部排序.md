---
title: 内部排序
keywords:
  - 内部排序
tags:
  - 内部排序
featured_image:
---

## 基本概念

内部排序是指排序期间数据元素全部存放在内存中的排序；
相应的，外部排序是指待排序的数据量很大，排序期间数据元素无法同时存放在内存中，必须在在排序过程中根据要求不断在内、外存之间移动的排序。

## 衡量指标

1. 稳定性

stable sort：插入排序、冒泡排序、归并排序、计数排序、基数排序、桶排序。
unstable sort：选择排序(5 8 5 2 9)、快速排序、堆排序。

为何排序的稳定性很重要？两个一样的元素的顺序有这么重要吗？其实很重要。在基数排序中显得尤为突出。

如果对于不稳定的算法进行改进，使得那些不稳定的算法也稳定？
其实很简单，只需要在每个输入元素加一个index，表示初始时的数组索引，当不稳定的算法排好序后，对于相同的元素对index排序即可。

2. 空间复杂度

In-place sort（不占用额外内存或占用常数的内存）：插入排序、选择排序、冒泡排序、堆排序、快速排序。
Out-place sort：归并排序、计数排序、基数排序、桶排序。
当需要对大量数据进行排序时，In-place sort就显示出优点，因为只需要占用常数的内存。

设想一下，如果要对10000个数据排序，如果使用了Out-place sort，则假设需要用200G的额外空间，则一台老式电脑会吃不消，但是如果使用In-place sort，则不需要花费额外内存。

3. 时间复杂度

基于比较的排序都是遵循“决策树模型”，而在决策树模型中，我们能证明基于比较的排序算法最坏情况下的运行时间为Ω(nlogn)，证明的思路是因为将n个序列构成的决策树的叶子节点个数至少有n!，因此高度至少为nlogn。

线性时间排序虽然能够理想情况下能在线性时间排序，但是每个排序都需要对输入数组做一些假设，比如计数排序需要输入数组数字范围为[0,k]等。

在排序算法的正确性证明中介绍了”循环不变式“，类似于数学归纳法，"初始"对应"n=1"，"保持"对应"假设n=k成立，当n=k+1时"。

4. 初态影响

## 分类


1. 插入排序

- 直接插入排序
- 折半插入排序
- 希尔排序

2. 交换排序

- 冒泡排序
- 快速排序

3. 选择排序

- 简单选择排序
- 堆排序

4. 归并排序
5. 计数/桶/基数排序

当n较大，则应采用时间复杂度为O(nlog2n)的排序方法：快速排序、堆排序或归并排序序。

**快速排序** 是目前基于比较的内部排序中被认为是最好的方法，当待排序的关键字是随机分布时，快速排序的平均时间最短。
